type: edu
custom_name: stage6
files:
- name: src/converter/Main.java
  visible: true
  text: |
    package converter;

    public class Main {
        public static void main(String[] args) {
            System.out.println("Hello World!");
        }
    }
  learner_created: false
- name: test/ConverterTest.java
  visible: false
  text: |
    import com.google.gson.*;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testcase.TestCase;

    import org.w3c.dom.*;

    import javax.xml.parsers.*;
    import java.io.*;

    import java.math.BigDecimal;
    import java.util.*;

    class Clue {
        String answer;
        String input;

        Clue(String answer, String input) {
            this.answer = answer.strip();
            this.input = input.strip();
        }
    }

    public class ConverterTest extends StageTest<Clue> {

        static Map<String, String> allTests;

        static {
            allTests = new LinkedHashMap<>();

            allTests.put(
                "{\n" +
                    "    \"transactions\": {\n" +
                    "        \"id\": \"6753322\",\n" +
                    "        \"data\": [\n" +
                    "            124,\n" +
                    "            true,\n" +
                    "            false,\n" +
                    "            [ ],\n" +
                    "            [],\n" +
                    "            { },\n" +
                    "            {},\n" +
                    "            [\n" +
                    "                1, 2, 3,\n" +
                    "                {\n" +
                    "                    \"@attr\": \"value6\",\n" +
                    "                    \"#element\": \"value7\"\n" +
                    "                }\n" +
                    "            ],\n" +
                    "            null,\n" +
                    "            \"\",\n" +
                    "            {\n" +
                    "                \"key1\": \"value1\",\n" +
                    "                \"key2\": {\n" +
                    "                    \"@attr\": \"value2\",\n" +
                    "                    \"#key2\": \"value3\"\n" +
                    "                }\n" +
                    "            },\n" +
                    "            {\n" +
                    "                \"@attr2\": \"value4\",\n" +
                    "                \"#element\": \"value5\"\n" +
                    "            }\n" +
                    "        ]\n" +
                    "    }\n" +
                    "}",


                "<transactions>\n" +
                    "    <id>6753322</id>\n" +
                    "    <data>\n" +
                    "        <element>124</element>\n" +
                    "        <element>true</element>\n" +
                    "        <element>false</element>\n" +
                    "        <element></element>\n" +
                    "        <element></element>\n" +
                    "        <element></element>\n" +
                    "        <element></element>\n" +
                    "        <element>\n" +
                    "            <element>1</element>\n" +
                    "            <element>2</element>\n" +
                    "            <element>3</element>\n" +
                    "            <element attr=\"value6\">value7</element>\n" +
                    "        </element>\n" +
                    "        <element />\n" +
                    "        <element></element>\n" +
                    "        <element>\n" +
                    "            <key1>value1</key1>\n" +
                    "            <key2 attr=\"value2\">value3</key2>\n" +
                    "        </element>\n" +
                    "        <element attr2=\"value4\">value5</element>\n" +
                    "    </data>\n" +
                    "</transactions>"
            );



            allTests.put(
                "<?xml version = \"1.0\" encoding = \"utf-8\"?>\n" +
                    "<transactions>\n" +
                    "    <transaction>\n" +
                    "        <id>6753323</id>\n" +
                    "        <number region = \"Russia\">8-900-000-00-00</number>\n" +
                    "        <date day = \"12\" month = \"12\" year = \"2018\"/>\n" +
                    "        <amount currency=\"EUR\">1000.00</amount>\n" +
                    "        <completed>true</completed>\n" +
                    "    </transaction>\n" +
                    "    <transaction>\n" +
                    "        <id>67533244</id>\n" +
                    "        <number region = \"Russia\">8-900-000-00-01</number>\n" +
                    "        <date day = \"13\" month = \"12\" year = \"2018\"/>\n" +
                    "        <amount currency =\"RUB\">2000.00</amount>\n" +
                    "        <completed>true</completed>\n" +
                    "    </transaction>\n" +
                    "    <transaction>\n" +
                    "        <id>67533257</id>\n" +
                    "        <number region=\"Russia\">8-900-000-00-02</number>\n" +
                    "        <date day = \"14\" month = \"12\" year = \"2018\"/>\n" +
                    "        <amount currency = \"EUR\">3000.00</amount>\n" +
                    "        <completed>false</completed>\n" +
                    "    </transaction>\n" +
                    "    <transaction>\n" +
                    "        <id>67533259</id>\n" +
                    "        <number region = \"Ukraine\">8-900-000-00-03</number>\n" +
                    "        <date day = \"15\" month = \"12\" year = \"2018\"/>\n" +
                    "        <amount currency = \"GRN\">4000.00</amount>\n" +
                    "        <completed>false</completed>\n" +
                    "    </transaction>\n" +
                    "    <transaction>\n" +
                    "        <id>67533566</id>\n" +
                    "        <number region = \"Ukraine\">8-900-000-00-04</number>\n" +
                    "        <date day = \"16\" month = \"12\" year = \"2018\"/>\n" +
                    "        <amount currency = \"USD\">5000.00</amount>\n" +
                    "        <completed>false</completed>\n" +
                    "    </transaction>\n" +
                    "</transactions>",


                "{\n" +
                    "    \"transactions\" : [\n" +
                    "        {\n" +
                    "            \"id\" : \"6753323\",\n" +
                    "            \"number\" : {\n" +
                    "                \"@region\" : \"Russia\",\n" +
                    "                \"#number\" : \"8-900-000-00-00\"\n" +
                    "            },\n" +
                    "            \"date\" : {\n" +
                    "                \"@day\" : \"12\",\n" +
                    "                \"@month\" : \"12\",\n" +
                    "                \"@year\" : \"2018\",\n" +
                    "                \"#date\" : null\n" +
                    "            },\n" +
                    "            \"amount\" : {\n" +
                    "                \"@currency\" : \"EUR\",\n" +
                    "                \"#amount\" : \"1000.00\"\n" +
                    "            },\n" +
                    "            \"completed\" : \"true\"\n" +
                    "        },\n" +
                    "        {\n" +
                    "            \"id\" : \"67533244\",\n" +
                    "            \"number\" : {\n" +
                    "                \"@region\" : \"Russia\",\n" +
                    "                \"#number\" : \"8-900-000-00-01\"\n" +
                    "            },\n" +
                    "            \"date\" : {\n" +
                    "                \"@day\" : \"13\",\n" +
                    "                \"@month\" : \"12\",\n" +
                    "                \"@year\" : \"2018\",\n" +
                    "                \"#date\" : null\n" +
                    "            },\n" +
                    "            \"amount\" : {\n" +
                    "                \"@currency\" : \"RUB\",\n" +
                    "                \"#amount\" : \"2000.00\"\n" +
                    "            },\n" +
                    "            \"completed\" : \"true\"\n" +
                    "        },\n" +
                    "        {\n" +
                    "            \"id\" : \"67533257\",\n" +
                    "            \"number\" : {\n" +
                    "                \"@region\" : \"Russia\",\n" +
                    "                \"#number\" : \"8-900-000-00-02\"\n" +
                    "            },\n" +
                    "            \"date\" : {\n" +
                    "                \"@day\" : \"14\",\n" +
                    "                \"@month\" : \"12\",\n" +
                    "                \"@year\" : \"2018\",\n" +
                    "                \"#date\" : null\n" +
                    "            },\n" +
                    "            \"amount\" : {\n" +
                    "                \"@currency\" : \"EUR\",\n" +
                    "                \"#amount\" : \"3000.00\"\n" +
                    "            },\n" +
                    "            \"completed\" : \"false\"\n" +
                    "        },\n" +
                    "        {\n" +
                    "            \"id\" : \"67533259\",\n" +
                    "            \"number\" : {\n" +
                    "                \"@region\" : \"Ukraine\",\n" +
                    "                \"#number\" : \"8-900-000-00-03\"\n" +
                    "            },\n" +
                    "            \"date\" : {\n" +
                    "                \"@day\" : \"15\",\n" +
                    "                \"@month\" : \"12\",\n" +
                    "                \"@year\" : \"2018\",\n" +
                    "                \"#date\" : null\n" +
                    "            },\n" +
                    "            \"amount\" : {\n" +
                    "                \"@currency\" : \"GRN\",\n" +
                    "                \"#amount\" : \"4000.00\"\n" +
                    "            },\n" +
                    "            \"completed\" : \"false\"\n" +
                    "        },\n" +
                    "        {\n" +
                    "            \"id\" : \"67533566\",\n" +
                    "            \"number\" : {\n" +
                    "                \"@region\" : \"Ukraine\",\n" +
                    "                \"#number\" : \"8-900-000-00-04\"\n" +
                    "            },\n" +
                    "            \"date\" : {\n" +
                    "                \"@day\" : \"16\",\n" +
                    "                \"@month\" : \"12\",\n" +
                    "                \"@year\" : \"2018\",\n" +
                    "                \"#date\" : null\n" +
                    "            },\n" +
                    "            \"amount\" : {\n" +
                    "                \"@currency\" : \"USD\",\n" +
                    "                \"#amount\" : \"5000.00\"\n" +
                    "            },\n" +
                    "            \"completed\" : \"false\"\n" +
                    "        }\n" +
                    "    ]\n" +
                    "}"
            );



            allTests.put(
                "{\n" +
                    "    \"transaction\": {\n" +
                    "        \"id\": \"6753324\",\n" +
                    "        \"number\": {\n" +
                    "            \"@region\": \"Russia\",\n" +
                    "            \"#number\": \"8-900-000-000\"\n" +
                    "        },\n" +
                    "        \"special1\": false,\n" +
                    "        \"special2\": true,\n" +
                    "        \"empty1\": null,\n" +
                    "        \"empty2\": { },\n" +
                    "        \"empty3\": [ ],\n" +
                    "        \"empty4\": {},\n" +
                    "        \"empty5\": [],\n" +
                    "        \"empty6\": {\n" +
                    "\n" +
                    "        },\n" +
                    "        \"empty7\": [\n" +
                    "\n" +
                    "        ],\n" +
                    "        \"empty8\": \"\",\n" +
                    "        \"array1\": [\n" +
                    "            null, null\n" +
                    "        ],\n" +
                    "        \"array2\": [\n" +
                    "            [],\n" +
                    "            true, false, null,\n" +
                    "            123, 123.456,\n" +
                    "            \"\",\n" +
                    "            {\n" +
                    "                \"key1\": \"value1\",\n" +
                    "                \"key2\": {\n" +
                    "                    \"@attr\": \"value2\",\n" +
                    "                    \"#key2\": \"value3\"\n" +
                    "                }\n" +
                    "            },\n" +
                    "            {\n" +
                    "                \"@attr2\": \"value4\",\n" +
                    "                \"#element\": \"value5\"\n" +
                    "            }\n" +
                    "            ,\n" +
                    "            {\n" +
                    "                \"@attr3\": \"value4\",\n" +
                    "                \"#elem\": \"value5\"\n" +
                    "            },\n" +
                    "            {\n" +
                    "                \"#element\": null\n" +
                    "            },\n" +
                    "            {\n" +
                    "                \"#element\": {\n" +
                    "                    \"deep\": {\n" +
                    "                        \"@deepattr\": \"deepvalue\",\n" +
                    "                        \"#deep\": [\n" +
                    "                            1, 2, 3\n" +
                    "                        ]\n" +
                    "                    }\n" +
                    "                }\n" +
                    "            }\n" +
                    "        ],\n" +
                    "        \"inner1\": {\n" +
                    "            \"inner2\": {\n" +
                    "                \"inner3\": {\n" +
                    "                    \"key1\": \"value1\",\n" +
                    "                    \"key2\": \"value2\"\n" +
                    "                }\n" +
                    "            }\n" +
                    "        },\n" +
                    "        \"inner4\": {\n" +
                    "            \"@\": 123,\n" +
                    "            \"#inner4\": \"value3\"\n" +
                    "        },\n" +
                    "        \"inner5\": {\n" +
                    "            \"@attr1\": 123.456,\n" +
                    "            \"#inner4\": \"value4\"\n" +
                    "        },\n" +
                    "        \"inner6\": {\n" +
                    "            \"@attr2\": 789.321,\n" +
                    "            \"#inner6\": \"value5\"\n" +
                    "        },\n" +
                    "        \"inner7\": {\n" +
                    "            \"#inner7\": \"value6\"\n" +
                    "        },\n" +
                    "        \"inner8\": {\n" +
                    "            \"@attr3\": \"value7\"\n" +
                    "        },\n" +
                    "        \"inner9\": {\n" +
                    "            \"@attr4\": \"value8\",\n" +
                    "            \"#inner9\": \"value9\",\n" +
                    "            \"something\": \"value10\"\n" +
                    "        },\n" +
                    "        \"inner10\": {\n" +
                    "            \"@attr5\": null,\n" +
                    "            \"#inner10\": null\n" +
                    "        },\n" +
                    "        \"inner11\": {\n" +
                    "            \"@attr11\": \"value11\",\n" +
                    "            \"#inner11\": {\n" +
                    "                \"inner12\": {\n" +
                    "                    \"@attr12\": \"value12\",\n" +
                    "                    \"#inner12\": {\n" +
                    "                        \"inner13\": {\n" +
                    "                            \"@attr13\": \"value13\",\n" +
                    "                            \"#inner13\": {\n" +
                    "                                \"inner14\": \"v14\"\n" +
                    "                            }\n" +
                    "                        }\n" +
                    "                    }\n" +
                    "                }\n" +
                    "            }\n" +
                    "        },\n" +
                    "        \"inner15\": {\n" +
                    "            \"@\": null,\n" +
                    "            \"#\": null\n" +
                    "        },\n" +
                    "        \"inner16\": {\n" +
                    "            \"@somekey\": \"attrvalue\",\n" +
                    "            \"#inner16\": null,\n" +
                    "            \"somekey\": \"keyvalue\",\n" +
                    "            \"inner16\": \"notnull\"\n" +
                    "        },\n" +
                    "        \"crazyattr1\": {\n" +
                    "            \"@attr1\": 123,\n" +
                    "            \"#crazyattr1\": \"v15\"\n" +
                    "        },\n" +
                    "        \"crazyattr2\": {\n" +
                    "            \"@attr1\": 123.456,\n" +
                    "            \"#crazyattr2\": \"v16\"\n" +
                    "        },\n" +
                    "        \"crazyattr3\": {\n" +
                    "            \"@attr1\": null,\n" +
                    "            \"#crazyattr3\": \"v17\"\n" +
                    "        },\n" +
                    "        \"crazyattr4\": {\n" +
                    "            \"@attr1\": true,\n" +
                    "            \"#crazyattr4\": \"v18\"\n" +
                    "        },\n" +
                    "        \"crazyattr5\": {\n" +
                    "            \"@attr1\": false,\n" +
                    "            \"#crazyattr5\": \"v19\"\n" +
                    "        },\n" +
                    "        \"crazyattr6\": {\n" +
                    "            \"@attr1\": \"\",\n" +
                    "            \"#crazyattr6\": \"v20\"\n" +
                    "        },\n" +
                    "        \"crazyattr7\": {\n" +
                    "            \"@attr1\": {},\n" +
                    "            \"#crazyattr7\": \"v21\"\n" +
                    "        },\n" +
                    "        \"crazyattr9\": {\n" +
                    "            \"@attr1\": {\n" +
                    "                \"@\": 1,\n" +
                    "                \"#\": 2,\n" +
                    "                \"\": 3,\n" +
                    "                \"key\": 4\n" +
                    "            },\n" +
                    "            \"#crazyattr9\": \"v23\"\n" +
                    "        },\n" +
                    "        \"crazyattr10\": {\n" +
                    "            \"@attr1\": [],\n" +
                    "            \"#crazyattr10\": \"v24\"\n" +
                    "        },\n" +
                    "        \"crazyattr11\": {\n" +
                    "            \"attr1\": \"better\",\n" +
                    "            \"@attr1\": {\n" +
                    "                \"key9\": \"value9\"\n" +
                    "            },\n" +
                    "            \"#crazyattr11\": \"v25\"\n" +
                    "        },\n" +
                    "        \"crazyattr12\": {\n" +
                    "            \"@attr1\": [\n" +
                    "                \"\"\n" +
                    "            ],\n" +
                    "            \"#crazyattr12\": \"v26\"\n" +
                    "        },\n" +
                    "        \"\": {\n" +
                    "            \"#\": null,\n" +
                    "            \"secret\": \"won't be converted\"\n" +
                    "        },\n" +
                    "        \"@\": 123,\n" +
                    "        \"#\": [\n" +
                    "            1, 2, 3\n" +
                    "        ]\n" +
                    "    },\n" +
                    "    \"meta\": {\n" +
                    "        \"version\": 0.01\n" +
                    "    }\n" +
                    "}",


                "<root>\n" +
                    "    <transaction>\n" +
                    "        <id>6753324</id>\n" +
                    "        <number region=\"Russia\">8-900-000-000</number>\n" +
                    "        <special1>false</special1>\n" +
                    "        <special2>true</special2>\n" +
                    "        <empty1 />\n" +
                    "        <empty2></empty2>\n" +
                    "        <empty3></empty3>\n" +
                    "        <empty4></empty4>\n" +
                    "        <empty5></empty5>\n" +
                    "        <empty6></empty6>\n" +
                    "        <empty7></empty7>\n" +
                    "        <empty8></empty8>\n" +
                    "        <array1>\n" +
                    "            <element />\n" +
                    "            <element />\n" +
                    "        </array1>\n" +
                    "        <array2>\n" +
                    "            <element></element>\n" +
                    "            <element>true</element>\n" +
                    "            <element>false</element>\n" +
                    "            <element />\n" +
                    "            <element>123</element>\n" +
                    "            <element>123.456</element>\n" +
                    "            <element></element>\n" +
                    "            <element>\n" +
                    "                <key1>value1</key1>\n" +
                    "                <key2 attr=\"value2\">value3</key2>\n" +
                    "            </element>\n" +
                    "            <element attr2=\"value4\">value5</element>\n" +
                    "            <element>\n" +
                    "                <attr3>value4</attr3>\n" +
                    "                <elem>value5</elem>\n" +
                    "            </element>\n" +
                    "            <element />\n" +
                    "            <element>\n" +
                    "                <deep deepattr=\"deepvalue\">\n" +
                    "                    <element>1</element>\n" +
                    "                    <element>2</element>\n" +
                    "                    <element>3</element>\n" +
                    "                </deep>\n" +
                    "            </element>\n" +
                    "        </array2>\n" +
                    "        <inner1>\n" +
                    "            <inner2>\n" +
                    "                <inner3>\n" +
                    "                    <key1>value1</key1>\n" +
                    "                    <key2>value2</key2>\n" +
                    "                </inner3>\n" +
                    "            </inner2>\n" +
                    "        </inner1>\n" +
                    "        <inner4>\n" +
                    "            <inner4>value3</inner4>\n" +
                    "        </inner4>\n" +
                    "        <inner5>\n" +
                    "            <attr1>123.456</attr1>\n" +
                    "            <inner4>value4</inner4>\n" +
                    "        </inner5>\n" +
                    "        <inner6 attr2=\"789.321\">value5</inner6>\n" +
                    "        <inner7>value6</inner7>\n" +
                    "        <inner8>\n" +
                    "            <attr3>value7</attr3>\n" +
                    "        </inner8>\n" +
                    "        <inner9>\n" +
                    "            <attr4>value8</attr4>\n" +
                    "            <inner9>value9</inner9>\n" +
                    "            <something>value10</something>\n" +
                    "        </inner9>\n" +
                    "        <inner10 attr5=\"\" />\n" +
                    "        <inner11 attr11=\"value11\">\n" +
                    "            <inner12 attr12=\"value12\">\n" +
                    "                <inner13 attr13=\"value13\">\n" +
                    "                    <inner14>v14</inner14>\n" +
                    "                </inner13>\n" +
                    "            </inner12>\n" +
                    "        </inner11>\n" +
                    "        <inner15></inner15>\n" +
                    "        <inner16>\n" +
                    "            <somekey>keyvalue</somekey>\n" +
                    "            <inner16>notnull</inner16>\n" +
                    "        </inner16>\n" +
                    "        <crazyattr1 attr1=\"123\">v15</crazyattr1>\n" +
                    "        <crazyattr2 attr1=\"123.456\">v16</crazyattr2>\n" +
                    "        <crazyattr3 attr1=\"\">v17</crazyattr3>\n" +
                    "        <crazyattr4 attr1=\"true\">v18</crazyattr4>\n" +
                    "        <crazyattr5 attr1=\"false\">v19</crazyattr5>\n" +
                    "        <crazyattr6 attr1=\"\">v20</crazyattr6>\n" +
                    "        <crazyattr7 attr1=\"\">v21</crazyattr7>\n" +
                    "        <crazyattr9>\n" +
                    "            <attr1>\n" +
                    "                <key>4</key>\n" +
                    "            </attr1>\n" +
                    "            <crazyattr9>v23</crazyattr9>\n" +
                    "        </crazyattr9>\n" +
                    "        <crazyattr10 attr1=\"\">v24</crazyattr10>\n" +
                    "        <crazyattr11>\n" +
                    "            <attr1>better</attr1>\n" +
                    "            <crazyattr11>v25</crazyattr11>\n" +
                    "        </crazyattr11>\n" +
                    "        <crazyattr12>\n" +
                    "            <attr1>\n" +
                    "                <element></element>\n" +
                    "            </attr1>\n" +
                    "            <crazyattr12>v26</crazyattr12>\n" +
                    "        </crazyattr12>\n" +
                    "    </transaction>\n" +
                    "    <meta>\n" +
                    "        <version>0.01</version>\n" +
                    "    </meta>\n" +
                    "</root>"
            );


            allTests.put(
                "<root>\n" +
                    "    <transaction>\n" +
                    "        <id>6753325</id>\n" +
                    "        <number region='Russia'>8-900-000-000</number>\n" +
                    "        <special1>false</special1>\n" +
                    "        <special2>true</special2>\n" +
                    "        <empty1 />\n" +
                    "        <empty2></empty2>\n" +
                    "        <array1>\n" +
                    "            <element />\n" +
                    "            <element />\n" +
                    "        </array1>\n" +
                    "        <array2>\n" +
                    "            <element></element>\n" +
                    "            <element />\n" +
                    "            <element>123</element>\n" +
                    "            <element>123.456</element>\n" +
                    "            <element>\n" +
                    "                <key1>value1</key1>\n" +
                    "                <key2 attr=\"value2\">value3</key2>\n" +
                    "            </element>\n" +
                    "            <element attr2='value4'>value5</element>\n" +
                    "            <element>\n" +
                    "                <attr3>value4</attr3>\n" +
                    "                <elem>value5</elem>\n" +
                    "            </element>\n" +
                    "            <element>\n" +
                    "                <deep deepattr=\"deepvalue\">\n" +
                    "                    <element>1</element>\n" +
                    "                    <element>2</element>\n" +
                    "                    <element>3</element>\n" +
                    "                </deep>\n" +
                    "            </element>\n" +
                    "        </array2>\n" +
                    "        <inner1>\n" +
                    "            <inner2>\n" +
                    "                <inner3>\n" +
                    "                    <key1>value1</key1>\n" +
                    "                    <key2>value2</key2>\n" +
                    "                </inner3>\n" +
                    "            </inner2>\n" +
                    "        </inner1>\n" +
                    "        <inner4>\n" +
                    "            <inner4>value3</inner4>\n" +
                    "        </inner4>\n" +
                    "        <inner5>\n" +
                    "            <attr1>123.456</attr1>\n" +
                    "            <inner4>value4</inner4>\n" +
                    "        </inner5>\n" +
                    "        <inner6 attr2=\"789.321\">value5</inner6>\n" +
                    "        <inner7>value6</inner7>\n" +
                    "        <inner8>\n" +
                    "            <attr3>value7</attr3>\n" +
                    "        </inner8>\n" +
                    "        <inner9>\n" +
                    "            <attr4>value8</attr4>\n" +
                    "            <inner9>value9</inner9>\n" +
                    "            <something>value10</something>\n" +
                    "        </inner9>\n" +
                    "        <inner10 attr5='' />\n" +
                    "        <inner11 attr11=\"value11\">\n" +
                    "            <inner12 attr12=\"value12\">\n" +
                    "                <inner13 attr13=\"value13\">\n" +
                    "                    <inner14>v14</inner14>\n" +
                    "                </inner13>\n" +
                    "            </inner12>\n" +
                    "        </inner11>\n" +
                    "        <inner15></inner15>\n" +
                    "        <inner16>\n" +
                    "            <somekey>keyvalue</somekey>\n" +
                    "            <inner16>notnull</inner16>\n" +
                    "        </inner16>\n" +
                    "        <crazyattr1 attr1='123'>v15</crazyattr1>\n" +
                    "        <crazyattr2 attr1=\"123.456\">v16</crazyattr2>\n" +
                    "        <crazyattr3 attr1=''>v17</crazyattr3>\n" +
                    "        <crazyattr9>\n" +
                    "            <attr1>\n" +
                    "                <key>4</key>\n" +
                    "            </attr1>\n" +
                    "            <crazyattr9>v23</crazyattr9>\n" +
                    "        </crazyattr9>\n" +
                    "    </transaction>\n" +
                    "    <meta>\n" +
                    "        <version>0.01</version>\n" +
                    "    </meta>\n" +
                    "</root>",


                "{\n" +
                    "    \"root\": {\n" +
                    "        \"transaction\": {\n" +
                    "            \"id\": \"6753325\",\n" +
                    "            \"number\": {\n" +
                    "                \"@region\": \"Russia\",\n" +
                    "                \"#number\": \"8-900-000-000\"\n" +
                    "            },\n" +
                    "            \"special1\": \"false\",\n" +
                    "            \"special2\": \"true\",\n" +
                    "            \"empty1\": null,\n" +
                    "            \"empty2\": \"\",\n" +
                    "            \"array1\": [\n" +
                    "                null, null\n" +
                    "            ],\n" +
                    "            \"array2\": [\n" +
                    "                \"\",\n" +
                    "                null,\n" +
                    "                \"123\",\n" +
                    "                \"123.456\",\n" +
                    "                {\n" +
                    "                    \"key1\": \"value1\",\n" +
                    "                    \"key2\": {\n" +
                    "                        \"@attr\": \"value2\",\n" +
                    "                        \"#key2\": \"value3\"\n" +
                    "                    }\n" +
                    "                },\n" +
                    "                {\n" +
                    "                    \"@attr2\": \"value4\",\n" +
                    "                    \"#element\": \"value5\"\n" +
                    "                },\n" +
                    "                {\n" +
                    "                    \"attr3\": \"value4\",\n" +
                    "                    \"elem\": \"value5\"\n" +
                    "                },\n" +
                    "                {\n" +
                    "                    \"deep\": {\n" +
                    "                        \"@deepattr\": \"deepvalue\",\n" +
                    "                        \"#deep\": [\n" +
                    "                            \"1\",\n" +
                    "                            \"2\",\n" +
                    "                            \"3\"\n" +
                    "                        ]\n" +
                    "                    }\n" +
                    "                }\n" +
                    "            ],\n" +
                    "            \"inner1\": {\n" +
                    "                \"inner2\": {\n" +
                    "                    \"inner3\": {\n" +
                    "                        \"key1\": \"value1\",\n" +
                    "                        \"key2\": \"value2\"\n" +
                    "                    }\n" +
                    "                }\n" +
                    "            },\n" +
                    "            \"inner4\": {\n" +
                    "                \"inner4\": \"value3\"\n" +
                    "            },\n" +
                    "            \"inner5\": {\n" +
                    "                \"attr1\": \"123.456\",\n" +
                    "                \"inner4\": \"value4\"\n" +
                    "            },\n" +
                    "            \"inner6\": {\n" +
                    "                \"@attr2\": \"789.321\",\n" +
                    "                \"#inner6\": \"value5\"\n" +
                    "            },\n" +
                    "            \"inner7\": \"value6\",\n" +
                    "            \"inner8\": {\n" +
                    "                \"attr3\": \"value7\"\n" +
                    "            },\n" +
                    "            \"inner9\": {\n" +
                    "                \"attr4\": \"value8\",\n" +
                    "                \"inner9\": \"value9\",\n" +
                    "                \"something\": \"value10\"\n" +
                    "            },\n" +
                    "            \"inner10\": {\n" +
                    "                \"@attr5\": \"\",\n" +
                    "                \"#inner10\": null\n" +
                    "            },\n" +
                    "            \"inner11\": {\n" +
                    "                \"@attr11\": \"value11\",\n" +
                    "                \"#inner11\": {\n" +
                    "                    \"inner12\": {\n" +
                    "                        \"@attr12\": \"value12\",\n" +
                    "                        \"#inner12\": {\n" +
                    "                            \"inner13\": {\n" +
                    "                                \"@attr13\": \"value13\",\n" +
                    "                                \"#inner13\": {\n" +
                    "                                    \"inner14\": \"v14\"\n" +
                    "                                }\n" +
                    "                            }\n" +
                    "                        }\n" +
                    "                    }\n" +
                    "                }\n" +
                    "            },\n" +
                    "            \"inner15\": \"\",\n" +
                    "            \"inner16\": {\n" +
                    "                \"somekey\": \"keyvalue\",\n" +
                    "                \"inner16\": \"notnull\"\n" +
                    "            },\n" +
                    "            \"crazyattr1\": {\n" +
                    "                \"@attr1\": \"123\",\n" +
                    "                \"#crazyattr1\": \"v15\"\n" +
                    "            },\n" +
                    "            \"crazyattr2\": {\n" +
                    "                \"@attr1\": \"123.456\",\n" +
                    "                \"#crazyattr2\": \"v16\"\n" +
                    "            },\n" +
                    "            \"crazyattr3\": {\n" +
                    "                \"@attr1\": \"\",\n" +
                    "                \"#crazyattr3\": \"v17\"\n" +
                    "            },\n" +
                    "            \"crazyattr9\": {\n" +
                    "                \"attr1\": {\n" +
                    "                    \"key\": \"4\"\n" +
                    "                },\n" +
                    "                \"crazyattr9\": \"v23\"\n" +
                    "            }\n" +
                    "        },\n" +
                    "        \"meta\": {\n" +
                    "            \"version\": \"0.01\"\n" +
                    "        }\n" +
                    "    }\n" +
                    "}"
            );


            allTests.put(
                "{\"transaction\":{\"id\":\"6753326\",\"number\":{\"@region\":\"Russia\",\"#number\":\"8-900-000-000\"},\"special1\":false,\"special2\":true,\"empty1\":null,\"empty2\":{},\"empty3\":[],\"empty4\":{},\"empty5\":[],\"empty6\":{},\"empty7\":[],\"empty8\":\"\",\"array1\":[null,null],\"array2\":[[],true,false,null,123,123.456,\"\",{\"key1\":\"value1\",\"key2\":{\"@attr\":\"value2\",\"#key2\":\"value3\"}},{\"@attr2\":\"value4\",\"#element\":\"value5\"},{\"@attr3\":\"value4\",\"#elem\":\"value5\"},{\"#element\":null},{\"#element\":{\"deep\":{\"@deepattr\":\"deepvalue\",\"#deep\":[1,2,3]}}}],\"inner1\":{\"inner2\":{\"inner3\":{\"key1\":\"value1\",\"key2\":\"value2\"}}},\"inner4\":{\"@\":123,\"#inner4\":\"value3\"},\"inner5\":{\"@attr1\":123.456,\"#inner4\":\"value4\"},\"inner6\":{\"@attr2\":789.321,\"#inner6\":\"value5\"},\"inner7\":{\"#inner7\":\"value6\"},\"inner8\":{\"@attr3\":\"value7\"},\"inner9\":{\"@attr4\":\"value8\",\"#inner9\":\"value9\",\"something\":\"value10\"},\"inner10\":{\"@attr5\":null,\"#inner10\":null},\"inner11\":{\"@attr11\":\"value11\",\"#inner11\":{\"inner12\":{\"@attr12\":\"value12\",\"#inner12\":{\"inner13\":{\"@attr13\":\"value13\",\"#inner13\":{\"inner14\":\"v14\"}}}}}},\"inner15\":{\"@\":null,\"#\":null},\"inner16\":{\"@somekey\":\"attrvalue\",\"#inner16\":null,\"somekey\":\"keyvalue\",\"inner16\":\"notnull\"},\"crazyattr1\":{\"@attr1\":123,\"#crazyattr1\":\"v15\"},\"crazyattr2\":{\"@attr1\":123.456,\"#crazyattr2\":\"v16\"},\"crazyattr3\":{\"@attr1\":null,\"#crazyattr3\":\"v17\"},\"crazyattr4\":{\"@attr1\":true,\"#crazyattr4\":\"v18\"},\"crazyattr5\":{\"@attr1\":false,\"#crazyattr5\":\"v19\"},\"crazyattr6\":{\"@attr1\":\"\",\"#crazyattr6\":\"v20\"},\"crazyattr7\":{\"@attr1\":{},\"#crazyattr7\":\"v21\"},\"crazyattr9\":{\"@attr1\":{\"@\":1,\"#\":2,\"\":3,\"key\":4},\"#crazyattr9\":\"v23\"},\"crazyattr10\":{\"@attr1\":[],\"#crazyattr10\":\"v24\"},\"crazyattr11\":{\"attr1\":\"better\",\"@attr1\":{\"key9\":\"value9\"},\"#crazyattr11\":\"v25\"},\"crazyattr12\":{\"@attr1\":[\"\"],\"#crazyattr12\":\"v26\"},\"\":{\"#\":null,\"secret\":\"won't be converted\"},\"@\":123,\"#\":[1,2,3]},\"meta\":{\"version\":0.01}}",


                "<root>\n" +
                    "    <transaction>\n" +
                    "        <id>6753326</id>\n" +
                    "        <number region=\"Russia\">8-900-000-000</number>\n" +
                    "        <special1>false</special1>\n" +
                    "        <special2>true</special2>\n" +
                    "        <empty1 />\n" +
                    "        <empty2></empty2>\n" +
                    "        <empty3></empty3>\n" +
                    "        <empty4></empty4>\n" +
                    "        <empty5></empty5>\n" +
                    "        <empty6></empty6>\n" +
                    "        <empty7></empty7>\n" +
                    "        <empty8></empty8>\n" +
                    "        <array1>\n" +
                    "            <element />\n" +
                    "            <element />\n" +
                    "        </array1>\n" +
                    "        <array2>\n" +
                    "            <element></element>\n" +
                    "            <element>true</element>\n" +
                    "            <element>false</element>\n" +
                    "            <element />\n" +
                    "            <element>123</element>\n" +
                    "            <element>123.456</element>\n" +
                    "            <element></element>\n" +
                    "            <element>\n" +
                    "                <key1>value1</key1>\n" +
                    "                <key2 attr=\"value2\">value3</key2>\n" +
                    "            </element>\n" +
                    "            <element attr2=\"value4\">value5</element>\n" +
                    "            <element>\n" +
                    "                <attr3>value4</attr3>\n" +
                    "                <elem>value5</elem>\n" +
                    "            </element>\n" +
                    "            <element />\n" +
                    "            <element>\n" +
                    "                <deep deepattr=\"deepvalue\">\n" +
                    "                    <element>1</element>\n" +
                    "                    <element>2</element>\n" +
                    "                    <element>3</element>\n" +
                    "                </deep>\n" +
                    "            </element>\n" +
                    "        </array2>\n" +
                    "        <inner1>\n" +
                    "            <inner2>\n" +
                    "                <inner3>\n" +
                    "                    <key1>value1</key1>\n" +
                    "                    <key2>value2</key2>\n" +
                    "                </inner3>\n" +
                    "            </inner2>\n" +
                    "        </inner1>\n" +
                    "        <inner4>\n" +
                    "            <inner4>value3</inner4>\n" +
                    "        </inner4>\n" +
                    "        <inner5>\n" +
                    "            <attr1>123.456</attr1>\n" +
                    "            <inner4>value4</inner4>\n" +
                    "        </inner5>\n" +
                    "        <inner6 attr2=\"789.321\">value5</inner6>\n" +
                    "        <inner7>value6</inner7>\n" +
                    "        <inner8>\n" +
                    "            <attr3>value7</attr3>\n" +
                    "        </inner8>\n" +
                    "        <inner9>\n" +
                    "            <attr4>value8</attr4>\n" +
                    "            <inner9>value9</inner9>\n" +
                    "            <something>value10</something>\n" +
                    "        </inner9>\n" +
                    "        <inner10 attr5=\"\" />\n" +
                    "        <inner11 attr11=\"value11\">\n" +
                    "            <inner12 attr12=\"value12\">\n" +
                    "                <inner13 attr13=\"value13\">\n" +
                    "                    <inner14>v14</inner14>\n" +
                    "                </inner13>\n" +
                    "            </inner12>\n" +
                    "        </inner11>\n" +
                    "        <inner15></inner15>\n" +
                    "        <inner16>\n" +
                    "            <somekey>keyvalue</somekey>\n" +
                    "            <inner16>notnull</inner16>\n" +
                    "        </inner16>\n" +
                    "        <crazyattr1 attr1=\"123\">v15</crazyattr1>\n" +
                    "        <crazyattr2 attr1=\"123.456\">v16</crazyattr2>\n" +
                    "        <crazyattr3 attr1=\"\">v17</crazyattr3>\n" +
                    "        <crazyattr4 attr1=\"true\">v18</crazyattr4>\n" +
                    "        <crazyattr5 attr1=\"false\">v19</crazyattr5>\n" +
                    "        <crazyattr6 attr1=\"\">v20</crazyattr6>\n" +
                    "        <crazyattr7 attr1=\"\">v21</crazyattr7>\n" +
                    "        <crazyattr9>\n" +
                    "            <attr1>\n" +
                    "                <key>4</key>\n" +
                    "            </attr1>\n" +
                    "            <crazyattr9>v23</crazyattr9>\n" +
                    "        </crazyattr9>\n" +
                    "        <crazyattr10 attr1=\"\">v24</crazyattr10>\n" +
                    "        <crazyattr11>\n" +
                    "            <attr1>better</attr1>\n" +
                    "            <crazyattr11>v25</crazyattr11>\n" +
                    "        </crazyattr11>\n" +
                    "        <crazyattr12>\n" +
                    "            <attr1>\n" +
                    "                <element></element>\n" +
                    "            </attr1>\n" +
                    "            <crazyattr12>v26</crazyattr12>\n" +
                    "        </crazyattr12>\n" +
                    "    </transaction>\n" +
                    "    <meta>\n" +
                    "        <version>0.01</version>\n" +
                    "    </meta>\n" +
                    "</root>"
            );


            allTests.put(
                "<root><transaction><id>6753327</id><number region='Russia'>8-900-000-000</number><special1>false</special1><special2>true</special2><empty1 /><empty2></empty2><array1><element /><element /></array1><array2><element></element><element /><element>123</element><element>123.456</element><element><key1>value1</key1><key2 attr=\"value2\">value3</key2></element><element attr2='value4'>value5</element><element><attr3>value4</attr3><elem>value5</elem></element><element><deep deepattr=\"deepvalue\"><element>1</element><element>2</element><element>3</element></deep></element></array2><inner1><inner2><inner3><key1>value1</key1><key2>value2</key2></inner3></inner2></inner1><inner4><inner4>value3</inner4></inner4><inner5><attr1>123.456</attr1><inner4>value4</inner4></inner5><inner6 attr2=\"789.321\">value5</inner6><inner7>value6</inner7><inner8><attr3>value7</attr3></inner8><inner9><attr4>value8</attr4><inner9>value9</inner9><something>value10</something></inner9><inner10 attr5='' /><inner11 attr11=\"value11\"><inner12 attr12=\"value12\"><inner13 attr13=\"value13\"><inner14>v14</inner14></inner13></inner12></inner11><inner15></inner15><inner16><somekey>keyvalue</somekey><inner16>notnull</inner16></inner16><crazyattr1 attr1='123'>v15</crazyattr1><crazyattr2 attr1=\"123.456\">v16</crazyattr2><crazyattr3 attr1=''>v17</crazyattr3><crazyattr9><attr1><key>4</key></attr1><crazyattr9>v23</crazyattr9></crazyattr9></transaction><meta><version>0.01</version></meta></root>",


                "{\n" +
                    "    \"root\": {" +
                    "        \"transaction\": {\n" +
                    "            \"id\": \"6753327\",\n" +
                    "            \"number\": {\n" +
                    "                \"@region\": \"Russia\",\n" +
                    "                \"#number\": \"8-900-000-000\"\n" +
                    "            },\n" +
                    "            \"special1\": \"false\",\n" +
                    "            \"special2\": \"true\",\n" +
                    "            \"empty1\": null,\n" +
                    "            \"empty2\": \"\",\n" +
                    "            \"array1\": [\n" +
                    "                null, null\n" +
                    "            ],\n" +
                    "            \"array2\": [\n" +
                    "                \"\",\n" +
                    "                null,\n" +
                    "                \"123\",\n" +
                    "                \"123.456\",\n" +
                    "                {\n" +
                    "                    \"key1\": \"value1\",\n" +
                    "                    \"key2\": {\n" +
                    "                        \"@attr\": \"value2\",\n" +
                    "                        \"#key2\": \"value3\"\n" +
                    "                    }\n" +
                    "                },\n" +
                    "                {\n" +
                    "                    \"@attr2\": \"value4\",\n" +
                    "                    \"#element\": \"value5\"\n" +
                    "                },\n" +
                    "                {\n" +
                    "                    \"attr3\": \"value4\",\n" +
                    "                    \"elem\": \"value5\"\n" +
                    "                },\n" +
                    "                {\n" +
                    "                    \"deep\": {\n" +
                    "                        \"@deepattr\": \"deepvalue\",\n" +
                    "                        \"#deep\": [\n" +
                    "                            \"1\",\n" +
                    "                            \"2\",\n" +
                    "                            \"3\"\n" +
                    "                        ]\n" +
                    "                    }\n" +
                    "                }\n" +
                    "            ],\n" +
                    "            \"inner1\": {\n" +
                    "                \"inner2\": {\n" +
                    "                    \"inner3\": {\n" +
                    "                        \"key1\": \"value1\",\n" +
                    "                        \"key2\": \"value2\"\n" +
                    "                    }\n" +
                    "                }\n" +
                    "            },\n" +
                    "            \"inner4\": {\n" +
                    "                \"inner4\": \"value3\"\n" +
                    "            },\n" +
                    "            \"inner5\": {\n" +
                    "                \"attr1\": \"123.456\",\n" +
                    "                \"inner4\": \"value4\"\n" +
                    "            },\n" +
                    "            \"inner6\": {\n" +
                    "                \"@attr2\": \"789.321\",\n" +
                    "                \"#inner6\": \"value5\"\n" +
                    "            },\n" +
                    "            \"inner7\": \"value6\",\n" +
                    "            \"inner8\": {\n" +
                    "                \"attr3\": \"value7\"\n" +
                    "            },\n" +
                    "            \"inner9\": {\n" +
                    "                \"attr4\": \"value8\",\n" +
                    "                \"inner9\": \"value9\",\n" +
                    "                \"something\": \"value10\"\n" +
                    "            },\n" +
                    "            \"inner10\": {\n" +
                    "                \"@attr5\": \"\",\n" +
                    "                \"#inner10\": null\n" +
                    "            },\n" +
                    "            \"inner11\": {\n" +
                    "                \"@attr11\": \"value11\",\n" +
                    "                \"#inner11\": {\n" +
                    "                    \"inner12\": {\n" +
                    "                        \"@attr12\": \"value12\",\n" +
                    "                        \"#inner12\": {\n" +
                    "                            \"inner13\": {\n" +
                    "                                \"@attr13\": \"value13\",\n" +
                    "                                \"#inner13\": {\n" +
                    "                                    \"inner14\": \"v14\"\n" +
                    "                                }\n" +
                    "                            }\n" +
                    "                        }\n" +
                    "                    }\n" +
                    "                }\n" +
                    "            },\n" +
                    "            \"inner15\": \"\",\n" +
                    "            \"inner16\": {\n" +
                    "                \"somekey\": \"keyvalue\",\n" +
                    "                \"inner16\": \"notnull\"\n" +
                    "            },\n" +
                    "            \"crazyattr1\": {\n" +
                    "                \"@attr1\": \"123\",\n" +
                    "                \"#crazyattr1\": \"v15\"\n" +
                    "            },\n" +
                    "            \"crazyattr2\": {\n" +
                    "                \"@attr1\": \"123.456\",\n" +
                    "                \"#crazyattr2\": \"v16\"\n" +
                    "            },\n" +
                    "            \"crazyattr3\": {\n" +
                    "                \"@attr1\": \"\",\n" +
                    "                \"#crazyattr3\": \"v17\"\n" +
                    "            },\n" +
                    "            \"crazyattr9\": {\n" +
                    "                \"attr1\": {\n" +
                    "                    \"key\": \"4\"\n" +
                    "                },\n" +
                    "                \"crazyattr9\": \"v23\"\n" +
                    "            }\n" +
                    "        },\n" +
                    "        \"meta\": {\n" +
                    "            \"version\": \"0.01\"\n" +
                    "        }\n" +
                    "    }\n" +
                    "}"
            );
        }

        @Override
        public List<TestCase<Clue>> generate() {

            List<TestCase<Clue>> tests = new ArrayList<>();

            for (String input : allTests.keySet()) {
                String answer = allTests.get(input);

                TestCase<Clue> test = new TestCase<>();
                test.addFile("test.txt", input);
                test.setAttach(new Clue(answer, input));

                tests.add(test);
            }

            return tests;
        }

        @Override
        public CheckResult check(String reply, Clue clue) {

            String user = reply.strip();
            String answer = clue.answer.strip();

            if (user.length() == 0) {
                return new CheckResult(false,
                    "Your output is empty line.");
            }

            CheckResult result;

            if (user.charAt(0) != '<' && user.charAt(0) != '{') {
                return new CheckResult(false,
                    "Your first symbol is wrong - " +
                        " should be '{' or '<'");
            }

            try {
                if (user.charAt(0) == '<' && answer.charAt(0) == '<') {
                    result = isEqualXMLs(user, answer);
                } else if (user.charAt(0) == '{' && answer.charAt(0) == '{') {
                    result = isEqualJSONs(user, answer);
                } else {
                    return new CheckResult(false,
                        "Your first symbol is wrong - " +
                            "'{' instead of '<' or vice versa" + "\n\n" + user + "\n\n" + answer);
                }
            } catch (Exception ex) {
                return new CheckResult(false,
                    "Can't check the output - invalid XML or JSON");
            }

            return result;
        }

        public static Element stringToXML(String str) throws Exception {
            DocumentBuilderFactory factory =
                DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();

            ByteArrayInputStream input = new ByteArrayInputStream(
                str.getBytes("UTF-8"));

            Document document = builder.parse(input);

            return document.getDocumentElement();
        }


        public static CheckResult isEqualXMLs(String s1, String s2) throws Exception {
            Element elem1 = stringToXML(s1);
            Element elem2 = stringToXML(s2);

            CheckResult result = isEqualXMLElements(elem1, elem2);

            if (!result.isCorrect()) {
                return result;
            } else {
                return isEqualXMLElements(elem2, elem1);
            }
        }

        public static CheckResult isEqualXMLElements(Element e1, Element e2) {
            // test name
            if (!e1.getNodeName().equals(e2.getNodeName())) {
                return new CheckResult(false,
                    "In XML: element name is incorrect");
            }

            // test attributes
            NamedNodeMap attributes = e1.getAttributes();
            for (int i = 0; i < attributes.getLength(); i++) {
                Attr attr = (Attr) attributes.item(i);

                String name = attr.getName();

                if (!e2.hasAttribute(name)) {
                    return new CheckResult(false,
                        "In XML: element doesn't have " +
                            "an attribute or has an excess attribute");
                }

                if (!attr.getValue().equals(e2.getAttribute(name))) {
                    return new CheckResult(false,
                        "In XML: element has an attribute " +
                            "but their values don't match");
                }
            }

            // test chidls
            if (e1.hasChildNodes() != e2.hasChildNodes()) {
                return new CheckResult(false,
                    "In XML: element doesn't have needed " +
                        "child nodes or has excess child nodes");
            }

            if (!e1.hasChildNodes()) {
                return CheckResult.correct();
            }

            NodeList childs1 = e1.getChildNodes();
            NodeList childs2 = e2.getChildNodes();

            List<Element> filteredChilds1 = new ArrayList<>();
            List<Element> filteredChilds2 = new ArrayList<>();

            for (int i = 0; i < childs1.getLength(); i++) {
                Object item = childs1.item(i);
                if (item instanceof Element) {
                    filteredChilds1.add((Element) childs1.item(i));
                }
            }

            for (int i = 0; i < childs2.getLength(); i++) {
                Object item = childs2.item(i);
                if (item instanceof Element) {
                    filteredChilds2.add((Element) childs2.item(i));
                }
            }

            if (filteredChilds1.size() != filteredChilds2.size()) {
                return new CheckResult(false,
                    "In XML: element doesn't have needed " +
                        "child nodes or has excess child nodes");
            }

            for (int i = 0; i < filteredChilds1.size(); i++) {

                Element elem1 = filteredChilds1.get(i);
                Element elem2 = filteredChilds2.get(i);

                CheckResult result = isEqualXMLElements(elem1, elem2);
                if (!result.isCorrect()) {
                    return result;
                }
            }

            return CheckResult.correct();
        }

        public static JsonElement stringToJSON(String str) {
            return new JsonParser().parse(str);
        }


        public static CheckResult isEqualJSONs(String s1, String s2) {
            JsonElement elem1 = stringToJSON(s1);
            JsonElement elem2 = stringToJSON(s2);

            CheckResult result = isEqualJSONElements(elem1, elem2);

            if (!result.isCorrect()) {
                return result;
            } else {
                return isEqualJSONElements(elem2, elem1);
            }
        }

        public static CheckResult isEqualJSONElements(JsonElement e1, JsonElement e2) {

            // check for null
            if (e1.isJsonNull() != e2.isJsonNull()) {
                return new CheckResult(false,
                    "In JSON: expected null but found something else " +
                        "(or vice versa)");
            }
            if (e1.isJsonNull()) {
                return CheckResult.correct();
            }


            // check for primitives
            if (e1.isJsonPrimitive() != e2.isJsonPrimitive()) {
                // number and boolean are also may be expected but
                // after converting from XML there can be only strings
                return new CheckResult(false,
                    "In JSON: expected string " +
                        "but found something else (or vice versa)");
            }
            if (e1.isJsonPrimitive()) {
                JsonPrimitive prim1 = e1.getAsJsonPrimitive();
                JsonPrimitive prim2 = e2.getAsJsonPrimitive();
                return compareJSONPrimitives(prim1, prim2);
            }


            // check for arrays
            if (e1.isJsonArray() != e2.isJsonArray()) {
                return new CheckResult(false,
                    "In JSON: expected array " +
                        "but found something else (or vice versa)");
            }
            if (e1.isJsonArray()) {
                JsonArray arr1 = e1.getAsJsonArray();
                JsonArray arr2 = e2.getAsJsonArray();
                return compareJSONArrays(arr1, arr2);
            }


            // check for objects
            if (e1.isJsonObject() != e2.isJsonObject()) {
                return new CheckResult(false,
                    "In JSON: expected object " +
                        "but found something else (or vice versa)");
            }
            if (e1.isJsonObject()) {
                JsonObject obj1 = e1.getAsJsonObject();
                JsonObject obj2 = e2.getAsJsonObject();
                return compareJSONObjects(obj1, obj2);
            }

            return CheckResult.correct();
        }


        public static CheckResult compareJSONPrimitives(JsonPrimitive prim1,
                                                        JsonPrimitive prim2) {

            if (prim1.isBoolean() && prim2.isBoolean()) {
                return new CheckResult(
                    prim1.getAsBoolean() == prim2.getAsBoolean(),
                    "In JSON: two boolean values don't match");
            }
            if (prim1.isNumber() && prim2.isNumber()) {
                BigDecimal num1 = prim1.getAsBigDecimal();
                BigDecimal num2 = prim2.getAsBigDecimal();
                return new CheckResult(num1.equals(num2),
                    "In JSON: two number values don't match");
            }
            if (prim1.isString() && prim2.isString()) {
                String num1 = prim1.getAsString();
                String num2 = prim2.getAsString();
                return new CheckResult(num1.equals(num2),
                    "In JSON: two string values don't match");
            }


            if (prim1.isString() && prim2.isNumber() ||
                prim1.isNumber() && prim2.isString()) {

                return new CheckResult(false,
                    "In JSON: expected string value but " +
                        "found number (or vice versa)");
            }
            if (prim1.isString() && prim2.isBoolean() ||
                prim1.isBoolean() && prim2.isString()) {

                return new CheckResult(false,
                    "In JSON: expected string value but " +
                        "found boolean (or vice versa)");
            }
            if (prim1.isNumber() && prim2.isBoolean() ||
                prim1.isBoolean() && prim2.isNumber()) {

                return new CheckResult(false,
                    "In JSON: expected number value but " +
                        "found boolean (or vice versa)");
            }

            return CheckResult.correct();
        }

        public static CheckResult compareJSONArrays(JsonArray arr1, JsonArray arr2) {
            if (arr1.size() != arr2.size()) {
                return new CheckResult(false,
                    "In JSON: array size is incorrect");
            }

            for (int i = 0; i < arr1.size(); i++) {
                JsonElement elem1 = arr1.get(i);
                JsonElement elem2 = arr2.get(i);

                CheckResult result = isEqualJSONElements(elem1, elem2);
                if (!result.isCorrect()) {
                    return result;
                }
            }

            return CheckResult.correct();
        }

        public static CheckResult compareJSONObjects(JsonObject obj1, JsonObject obj2) {

            for (String key : obj1.keySet()) {
                if (!obj2.has(key)) {
                    return new CheckResult(false,
                        "In JSON: object doesn't have " +
                            "needed key or has an excess key");
                }

                JsonElement value1 = obj1.get(key);
                JsonElement value2 = obj2.get(key);

                CheckResult result = isEqualJSONElements(value1, value2);
                if (!result.isCorrect()) {
                    return result;
                }
            }

            return CheckResult.correct();
        }
    }
  learner_created: false
- name: src/converter/model/Generator.java
  visible: true
  text: |-
    package converter.model;

    import java.util.List;

    /**
     * abstract generator, that bundles the recursion functionality of the
     * XML and JSon-Generator - and a third GenericGenerator for project stage 3.
     */
    public abstract class Generator {

        protected String INDENT = "  ";
        protected StringBuilder builder;

        /**
         * entry point to start generation of Output-format
         * @param data a (probably nested) generic data object that represents the user inputs'
         *             data structure and is produced by a XMLParser or JsonParser object.
         * @return generated output
         */
        public String generate(DataStructureElement data) {
            builder = new StringBuilder(getInitialText());
            recursiveGenerate(data, getInitialIndentLevel());
            builder.append(getFinalText());
            return builder.toString();
        }

        /**
         * the central recursive generator method, called by generate(data)
         * @param data some DataStructureElement, which should be generated in the format desired
         * @param indentationLevel recursion depth, mainly used for indentation
         */
        protected void recursiveGenerate(DataStructureElement data, int indentationLevel) {
            generateAttributes(data, indentationLevel);

            if (data instanceof LeafElement) {
                generateLeafValue((LeafElement) data, indentationLevel);
                return;
            }

            generateEndOfParentAttribute(data, indentationLevel);
            List<DataStructureElement> values = ((ParentElement) data).getValue();
            for (DataStructureElement value : values) {
                recursiveGenerate(value, data.getAttributeElements() == null ? indentationLevel + 1
                        : indentationLevel + 2);
            }
            generateEndOfParent(data, indentationLevel);
        }

        /**
         * Generator-subclasses can start deeper indented (needed for Json)
         * @return initial indentation level
         */
        protected abstract int getInitialIndentLevel();

        /**
         * Generator-subclasses can specify some starter string (needed for Json: "{\n" )
         * @return the string to append to the StringBuilder
         */
        protected abstract String getInitialText();

        /**
         * Generator-subclasses can specify some ending string (needed for Json: "}\n" )
         * @return the string to append to the StringBuilder
         */
        protected abstract String getFinalText();

        /**
         * append an end marker after generating the element attribute (e.g. ">\n" in XML)
         * @param data associated DataStructureElement
         * @param indentationLevel recursion depth for indentation (e.g. used in Json)
         */
        protected abstract void generateEndOfParentAttribute(DataStructureElement data, int indentationLevel);

        /**
         * get String for a key:value line of an attribute in the appropriate format
         * method is not abstract, as the implementation is used as a default.
         * @param attribute attribute element's attribute name
         * @param value attribute element's value in quotes
         */
        protected String getAttributesElementString(String attribute, String value) {
            return String.format(" %s = \"%s\"", attribute, value);
        }

        /**
         * append an end marker after generating a parent structure object (e.g. "},\n" in XML)
         * @param data associated DataStructureElement
         * @param indentationLevel recursion depth for indentation (e.g. used in Json)
         */
        protected abstract void generateEndOfParent(DataStructureElement data, int indentationLevel);

        /** only for LeafElements, the value string is appended by this method hook in the format
         * @param data associated LeafElement
         * @param indentationLevel recursion depth for indentation (e.g. used in Json)
         */
        protected abstract void generateLeafValue(LeafElement data, int indentationLevel);

        /** generation of XML-element with attributes and its project-specific counterpart-implementation
         * in Json is very different for those types - so this is pure format specific logic.
         * @param data associated DataStructureElement
         * @param indentationLevel recursion depth for indentation (e.g. used in Json)
         */
        protected abstract void generateAttributes(DataStructureElement data, int indentationLevel);
    }
  learner_created: true
- name: src/converter/view/ScannerUI.java
  visible: true
  text: |-
    package converter.view;

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Paths;
    import java.util.Objects;
    import java.util.Scanner;

    /**
     * simple UI-class, that prompts the User for Input and returns the
     * scan result to the caller.
     */
    public class ScannerUI {

        public static final String NO_PROMPT = null;

        private final Scanner scanner = new Scanner(System.in);

        /**
         * prompts for an input (currently one line as string)
         * @param promptText the promptText
         * @return line of user input
         */
        public String getUserInput(String promptText) {
            if (!Objects.equals(promptText, NO_PROMPT)) {
                System.out.println(promptText);
            }
            return scanner.nextLine();
        }

        public String getUserInputFromFile(){
            try {
                return new String(Files.readAllBytes(
                        Paths.get("test.txt")));
            } catch (IOException e) {
                e.printStackTrace();
            }
            return null;
        }
    }
  learner_created: true
- name: src/converter/model/ParentElement.java
  visible: true
  text: |-
    package converter.model;

    import java.util.ArrayList;
    import java.util.List;

    /**
     * Class representing a data element with a structured value, i.e. an element,
     * that has child elements in Json and child tags or attributes in HTML.
     * It consists of an attribute-value pair, where attribute is represented by a string
     * and the value is a List of DataStructureElements (possibly empty or with one entry)
     * as well as a list of LeafElements representing the XML-attribute-value pairs.
     */
    public class ParentElement implements DataStructureElement {

        private String attribute= null;
        private List<LeafElement> attributeElements = null;
        private List<DataStructureElement> value = null;

        @Override
        public String getAttribute() {
            return attribute;
        }

        @Override
        public void setAttribute(String attribute) {
            this.attribute = attribute;
        }

        @Override
        public void addAttributeElement(LeafElement element) {
            if (attributeElements == null) {
                attributeElements = new ArrayList<>();
            }
            attributeElements.add(element);
        }

        /**
         * method (in addition to the DataStructureElement - so variable has to be of this type or cast
         * to be used) that adds a DataStructureElement to the list of values.
         * Thus, the parent element can contain a nested list of child elements - which
         * form the value field of the interface.
         * @param element the value element to be added
         */
        public void addValueElement(DataStructureElement element) {
            if (value == null) {
                value = new ArrayList<>();
            }
            value.add(element);
        }

        @Override
        public List<DataStructureElement> getValue() {
            return value;
        }

        @Override
        public List<LeafElement> getAttributeElements() {
            return attributeElements;
        }
    }
  learner_created: true
- name: src/converter/model/XMLGenerator.java
  visible: true
  text: |-
    package converter.model;

    /**
     * converts an abstract data structure attribute:value into text-lines in XML-format.
     */
    public class XMLGenerator extends Generator {

        @Override
        protected String getFinalText() {
            return "";
        }

        @Override
        protected String getInitialText() {
            return "";
        }

        @Override
        protected int getInitialIndentLevel() {
            return 0;
        }

        @Override
        protected void generateLeafValue(LeafElement data, int indentationLevel) {
            builder.append(getLeafValueString(data.getAttribute(), data.getValue()));
        }

        @Override
        protected String getAttributesElementString(String attribute, String value) {
            return String.format(" %s=\"%s\"", attribute, value);
        }

        @Override
        protected void generateEndOfParentAttribute(DataStructureElement data, int indentationLevel) {
            builder.append(">\n");
        }

        @Override
        protected void generateEndOfParent(DataStructureElement data, int indentationLevel) {
            builder.append(INDENT.repeat(indentationLevel))
                    .append(String.format("</%s>%n", data.getAttribute()));
        }

        @Override
        protected void generateAttributes(DataStructureElement data, int indentationLevel) {
            builder.append(INDENT.repeat(indentationLevel)).append(String.format("<%s", data.getAttribute()));
            if (data.getAttributeElements() != null) {
                for (LeafElement element : data.getAttributeElements()) {
                    builder.append(getAttributesElementString(element.getAttribute(), element.getValue()));
                }
            }
        }

        private String getLeafValueString(String attribute, String value) {
            return value == null ? "/>\n" : String.format(">%s</%s>%n", value, attribute);
        }
    }
  learner_created: true
- name: src/converter/model/JsonXMLParseException.java
  visible: true
  text: |
    package converter.model;

    /**
     * parse errors in any depth on the calling stack during parsing
     * cause exception object of this class to be thrown to the Controller.
     */
    public class JsonXMLParseException extends RuntimeException {

        public JsonXMLParseException(String message) {
            super(message);
        }
    }
  learner_created: true
- name: src/converter/model/DataStructureElement.java
  visible: true
  text: |-
    package converter.model;

    import java.util.List;

    /**
     * implementations of this interface represent an abstract attribute:value
     * data structure, where the value can be nested.
     * implementing classes should consist of at least an
     * - attribute string field named "attribute"
     * - attributeElements field named "attributeElements" of type List<LeafElement>
     * - value Element field named "value", which can be of several types,
     *      e.g. String or List<DataStructureElements> - but also Integer, Date etc.
     */
    public interface DataStructureElement {

        String getAttribute();

        List<LeafElement> getAttributeElements();

        /**
         * getter vor value of generic type Object. The value is given on construction for LeafElement
         * or by a non-interface method addValueElement() in case of ParentElement implementation
         * -> thus no setter needed presently, also to avoid casting...
         * @return the value as Object - implementations specify the return type further
         */
        Object getValue();

        void setAttribute(String attribute);

        /**
         * adds a LeafElement representing an attribute-value pair to the attributeElements list
         * @param element a Leafelement to be added to the list attributeElements
         */
        void addAttributeElement(LeafElement element);
    }
  learner_created: true
- name: src/converter/controller/JsonXMLConverter.java
  visible: true
  text: |-
    package converter.controller;


    import converter.model.*;
    import converter.view.PrinterUI;
    import converter.view.ScannerUI;

    import java.util.List;

    /**
     * Controller Class of the Json-XML-Converter
     */
    public class JsonXMLConverter {

        // model and view classes as fields - so they can be mocked in unit test :-)
        private ScannerUI scannerUI = new ScannerUI();
        private PrinterUI printerUI = new PrinterUI();
        private JsonGenerator jsonGenerator = new JsonGenerator();
        private XMLGenerator xmlGenerator = new XMLGenerator();
        private GenericGenerator genericGenerator = new GenericGenerator();

        /**
         * entry point for main application. Converts and prints user input.
         * For project stage 2 inout is taken from a text file test.txt - so this is done
         * here too: src/test/resources/data/test.txt
         */
        public void run() {
            // comment next line in - for check in JetBrains:
            String userInput = scannerUI.getUserInputFromFile().trim();
            //String userInput = scannerUI.getUserInput("Enter XML or Json to convert (one line):").trim();
            String output;

            try {
                output = convertInput(userInput);
            } catch (JsonXMLParseException e) {
                output = "Json-XML-Parse-Error - Illegal format:\n" + e.getMessage();
            }
            printerUI.print(output);
        }

        /**
         * Method recognizes format at first non-whitespace character and calls appropriate
         * parser and generator.
         * @param userInput the user input
         * @return the converted output
         */
        String convertInput(String userInput) {
            if (userInput.isEmpty()) {
                throw new JsonXMLParseException("Empty input!");
            }
            DataStructureElement dataStructure;
            switch (userInput.charAt(0)) {
                case '<':
                    dataStructure = new XMLParser().parse(userInput);
                    return jsonGenerator.generate(dataStructure);
                case '{':
                    dataStructure = new JsonParser().parse(userInput);
                    return xmlGenerator.generate(dataStructure);
                default:
                    throw new JsonXMLParseException("Input is neither valid XML nor Json," +
                            " invalid first non-whitespace character!");
            }
        }
    }
  learner_created: true
- name: src/converter/view/PrinterUI.java
  visible: true
  text: |-
    package converter.view;

    /**
     * simple UI class to handle output of converting, i.e. writing to stdout as of now.
     */
    public class PrinterUI {

        public void print(String output) {
            System.out.println(output);
        }
    }
  learner_created: true
- name: src/converter/model/JsonGenerator.java
  visible: true
  text: |-
    package converter.model;

    /**
     * converts an abstract data structure attribute:value into text-lines in Json-format.
     */
    public class JsonGenerator extends Generator {
        private static final String START_LINE = "{\n";
        private static final String END_LINE = "}\n";

        /**
         * as a side effect, this method removes an extra ',', that is appended to each
         * parent element at the end...
         * @return the end line
         */
        @Override
        protected String getFinalText() {
            builder.deleteCharAt(builder.lastIndexOf(",")); // remove last ','
            return END_LINE;
        }

        @Override
        protected int getInitialIndentLevel() {
            return 1;
        }

        @Override
        protected String getInitialText() {
            return START_LINE;
        }

        /**
         * project specification declares XML tags with attributes to be generated in a special form:
         * the value of such an XML-native element is a Json object, that
         * consists of attribute:value pairs, where the Json-attribute is marked with an @sign ("@attrib" = "val")
         * possible tag content is generated in Json as element #tagname:content.
         * Ex: <xml a1="v1" a2="v2">data</xml> gets:    "xml": { "@a1": "v1", "@a2":"v2", "#xml":"data }
         *    or <xml attr="val"/>             gets     "xml" : { "@attr":"val", "#xml":null }
         * @param data the generic key - attributes - value element to be generated
         * @param indentationLevel the indentation (recursion) level, how deep the element has to be indented
         */
        @Override
        protected void generateAttributes(DataStructureElement data, int indentationLevel) {
            builder.append(INDENT.repeat(indentationLevel))
                    .append(String.format("\"%s\": ", data.getAttribute()));
            if (data.getAttributeElements() == null) {
                return;
            }
            builder.append("{\n");
            for (LeafElement element : data.getAttributeElements()) {
                builder.append(INDENT.repeat(indentationLevel + 1))
                        .append(String.format("\"%s%s\": ", "@", element.getAttribute()));
                builder.append(getLeafValueString(element.getValue()));
            }
        }

        @Override
        protected void generateEndOfParentAttribute(DataStructureElement data, int indentationLevel) {
            if (data.getAttributeElements() != null) {
                builder.append(INDENT.repeat(indentationLevel + 1))
                        .append(String.format("\"%s%s\": {\n", "#", data.getAttribute()));
            } else {
                builder.append("{\n");
            }
        }

        @Override
        protected void generateEndOfParent(DataStructureElement data, int indentationLevel) {
            builder.deleteCharAt(builder.lastIndexOf(",")); // remove last ','
            if (data.getAttributeElements() != null) {
                builder.append(INDENT.repeat(indentationLevel + 1)).append("}\n");
            }
            builder.append(INDENT.repeat(indentationLevel)).append("},\n");
        }

        private String getLeafValueString(String value) {
            return value == null ? "null,\n" : String.format("\"%s\",%n", value);
        }

        /**
         * method contains some logic, as it can handle XML-elements with attributes as
         * well as standard XML-elements, that better correspond to Json-objects
         * @param data associated LeafElement
         * @param indentationLevel recursion depth for indentation (e.g. used in Json)
         */
        @Override
        protected void generateLeafValue(LeafElement data, int indentationLevel) {
            if (data.getAttributeElements() == null) {
                builder.append(getLeafValueString(data.getValue()));
            } else {
                builder.append(INDENT.repeat(indentationLevel + 1))
                        .append(String.format("\"%s%s\": ", "#", data.getAttribute()));
                builder.append(getLeafValueString(data.getValue()));
                builder.deleteCharAt(builder.lastIndexOf(",")); // remove last ','
                builder.append(INDENT.repeat(indentationLevel)).append("},\n");
            }
        }
    }
  learner_created: true
- name: src/converter/model/LeafElement.java
  visible: true
  text: |-
    package converter.model;

    import java.util.ArrayList;
    import java.util.List;

    /**
     * Class representing a data leaf element, i.e. an element, that has no child elements.
     * It consists of an attribute-value pair, which are both represented by strings.
     * An empty value string represents the Json-null value.
     * Further it contains a (possibly null) list of attribute elements (which are itself LeafElement's)
     */
    public class LeafElement implements DataStructureElement {

        private String attribute= null;
        private List<LeafElement> attributeElements;
        private String value;

        public LeafElement(String attribute, String value) {
            this.attribute = attribute;
            this.value = value;
        }

        public LeafElement(String value) {
            this.value = value;
        }

        @Override
        public String getAttribute() {
            return attribute;
        }

        @Override
        public String getValue() {
            return value;
        }

        @Override
        public void setAttribute(String attribute) {
            this.attribute = attribute;
        }

        @Override
        public void addAttributeElement(LeafElement element) {
            if (attributeElements == null) {
                attributeElements = new ArrayList<>();
            }
            attributeElements.add(element);
        }

        @Override
        public List<LeafElement> getAttributeElements() {
            return attributeElements;
        }

        public void setValue(String value) {
            this.value = value;
        }
    }
  learner_created: true
- name: src/converter/model/XMLParser.java
  visible: true
  text: |-
    package converter.model;

    import java.util.regex.Matcher;
    import java.util.regex.Pattern;

    /**
     * XMLParser objects contain all logic to parse string input in XML into abstract nested
     * data structures of attribute:value.
     * Implementation here is rather complex - by nature of the task - but is already
     * refactored, completely working and tested and near final.
     */
    public class XMLParser {

        private final Pattern XML_UNPAIRED_ELEMENT_PATTERN = Pattern.compile("(?s)<([^>]+)/>\\s*");
        private final Pattern XML_PAIRED_ELEMENT_PATTERN = Pattern.compile("(?s)<(([^>]+)[^>]*)>?(.*?)</\\2>\\s*");
        private final Pattern XML_TAG_PATTERN = Pattern.compile("(\\w+)\\s*(.*?)\\s*");
        private final Pattern XML_ATTRIBUTE_PATTERN = Pattern.compile("(\\w+)\\s*=\\s*\"(.*?[^\\\\])\"\\s*");

        /**
         * central parse method entry point for this class, that is also called recursively with
         * smaller sub parts of the input string given
         * Central ingredient are the matcher patterns of UNPAIRED and PAIRED XML elements
         * @param input at first call the complete user input - typically given by a file read
         *              smaller parts in recursion calls
         * @return generic data in form of a DataStructureElement
         */
        public DataStructureElement parse(String input) {

            Matcher matcher = XML_UNPAIRED_ELEMENT_PATTERN.matcher(input);
            if (matcher.find() && matcher.start() == 0) {
                // first recursion base case
                LeafElement parsedData = new LeafElement(null);
                parseAttributes(parsedData, matcher.group(1));
                return parsedData;
            }

            matcher = XML_PAIRED_ELEMENT_PATTERN.matcher(input);
            if (!matcher.find() || matcher.start() != 0) {
                throw new JsonXMLParseException("XML parser: invalid format found!");
            }
            String attribute = matcher.group(1);
            String value = matcher.group(3);

            // second recursion base case
            if (!isNested(value)) {
                LeafElement parsedData = new LeafElement(value);
                parseAttributes(parsedData, attribute);
                return parsedData;
            }

            ParentElement parsedData = new ParentElement();
            parseAttributes(parsedData, attribute);

            value = value.trim();
            int indexShift = 0; // keep track, that whole input is matched
            do {
                matcher = XML_UNPAIRED_ELEMENT_PATTERN.matcher(value);
                if (!matcher.find(indexShift) || matcher.start() != indexShift) {
                    matcher = XML_PAIRED_ELEMENT_PATTERN.matcher(value);
                    if (!matcher.find(indexShift) || matcher.start() != indexShift) {
                        throw new JsonXMLParseException("XML parser: invalid format found!");
                    }
                }
                // reduction step of recursion
                parsedData.addValueElement(parse(value.substring(matcher.start(), matcher.end()).trim()));
                indexShift = matcher.end();
            } while (matcher.end() < value.length());

            return parsedData;
        }

        /**
         * parse an attribute string with tag name and attributes list as extracted by the pattern's
         * of the parse-method.
         * @param dataStructure the DataStructureElement, where the parsing gets filled into
         * @param attribute the string, that is to be parsed
         */
        protected void parseAttributes(DataStructureElement dataStructure, String attribute) {
            Matcher matcher = XML_TAG_PATTERN.matcher(attribute);
            if (!matcher.matches()) {
                throw new JsonXMLParseException("XML parser: unsupported format yet!");
            }
            dataStructure.setAttribute(matcher.group(1));
            String attributeList = matcher.group(2);
            if (attributeList == null) {
                return;
            }
            matcher = XML_ATTRIBUTE_PATTERN.matcher(attribute);
            while (matcher.find()) {
                dataStructure.addAttributeElement(new LeafElement(matcher.group(1), matcher.group(2)));
            }
        }

        protected boolean isNested(String value) {
            return value.contains("<");
        }
    }
  learner_created: true
- name: src/converter/model/GenericGenerator.java
  visible: true
  text: |-
    package converter.model;

    import java.util.ArrayList;
    import java.util.List;

    /**
     * for project stage 3 a generic data format has to be generated, which is provided
     * by this Generator-subclass. For every element a hierarchy path has to be printed
     * so we keep track of that with a list field.
     */
    public class GenericGenerator extends Generator {

        public GenericGenerator() {
            super();
            // no indentation here
            INDENT = "";
        }

        private final List<String> pathList = new ArrayList<>();

        @Override
        protected String getInitialText() {
            return "";
        }

        @Override
        protected int getInitialIndentLevel() {
            return 0;
        }

        @Override
        protected String getFinalText() {
            return "";
        }

        @Override
        protected void generateEndOfParentAttribute(DataStructureElement data, int indentationLevel) {
            // nothing to do for Generic data format
        }

        @Override
        protected void generateEndOfParent(DataStructureElement data, int indentationLevel) {
            // nothing to do for Generic data format
        }

        @Override
        protected void generateLeafValue(LeafElement data, int indentationLevel) {
            //do nothing - already done in generateAttributes
        }

        /**
         * this is the key method of this generator, that does all the relevant formatted
         * output for an element
         * @param data associated DataStructureElement
         * @param indentationLevel recursion depth for indentation (not used here)
         */
        @Override
        protected void generateAttributes(DataStructureElement data, int indentationLevel) {
            while (pathList.size() > indentationLevel) {
                pathList.remove(pathList.size() - 1);
            }
            pathList.add(data.getAttribute());
            builder.append("Element:\npath = ");
            for (String pathElement : pathList) {
                builder.append(pathElement).append(", ");
            }
            builder.delete(builder.length() - 2, builder.length()).append("\n");
            if (data instanceof LeafElement) {
                generateValue((LeafElement) data);
            }
            if (data.getAttributeElements() != null) {
                generateAttributeElements(data.getAttributeElements());
            }
            builder.append("\n");
        }

        private void generateValue(LeafElement data) {
            builder.append("value = ")
                    .append(data.getValue() == null ? "null" : String.format("\"%s\"", data.getValue()))
                    .append("\n");
        }

        private void generateAttributeElements(List<LeafElement> elements) {
            builder.append("attributes:\n");
            for (LeafElement element : elements) {
                builder.append(String.format("%s = \"%s\"%n", element.getAttribute(), element.getValue()));
            }
        }
    }
  learner_created: true
- name: src/converter/model/JsonParser.java
  visible: true
  text: |-
    package converter.model;

    import java.util.*;
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;

    /**
     * JsonParser objects contain all logic to parse string input in Json-format into abstract nested
     * data structures of attribute:value.
     * TO BE REFACTORED in next stage(s) !!! It uses the obsolete LeafAttributesElement - class
     * and also cannot handle well recursive structures yet...
     */
    public class JsonParser {

        private final Pattern SINGLE_ROOT_PATTERN
                = Pattern.compile("(?s)\"([.\\w]*)\"\\s*:\\s*\\{(.*)}\\s*");
        private final Pattern SINGLE_NON_EMPTY_STRING_PATTERN
                = Pattern.compile("(?s)\"([.\\w]*)\"\\s*:\\s*\"(.*?[^\\\\])\"");
        private final Pattern SINGLE_EMPTY_STRING_PATTERN = Pattern.compile("(?s)\"(\\w*)\"\\s*:\\s*\"\"");
        private final Pattern SINGLE_NUMBER_PATTERN
                = Pattern.compile("(?s)\"([.\\w]*)\"\\s*:\\s*([-+]?[0-9]*\\.?[0-9]+)");
        private final Pattern SINGLE_BOOLEAN_PATTERN
                = Pattern.compile("(?s)\"([.\\w]*)\"\\s*:\\s*(true|false)");
        private final Pattern SINGLE_NULL_PATTERN
                = Pattern.compile("(?s)\"([.\\w]*)\"\\s*:\\s*null");
        private final Pattern JSON_ATTRIBUTE_PATTERN
                = Pattern.compile("(?s)\"[@#]([.\\w]+)\"\\s*:\\s*(\"([^\"]*?)\"|[^\\s{]+)");
        private final Pattern JSON_CHILD_TOKEN_PATTERN = Pattern.compile("(?s)\"([@#]?[.\\w]*)\".*");

        /**
         * entry point for controller to parse the (complete) user input.
         * results are stored in model objects
         * @return the parsed data as abstract DataStructureElement
         */
        public DataStructureElement parse(String input) {
            if (!input.endsWith("}")) {
                throw new JsonXMLParseException(
                        "Json parser: invalid Json-format found (array as root element not supported yet)!");
            }
            ParentElement rootElement = new ParentElement();
            // cut off enclosing braces and whitespace and parse
            parseObjectsList(rootElement, input.substring(1, input.length() - 1).trim());
            if (rootElement.getValue().size() == 1) {
                return rootElement.getValue().get(0);
            }
            rootElement.setAttribute("root");
            return rootElement;
        }

        /**
         * central recursive method of this parser, that does the scanning of the child list of a
         * Json object (i.e. anything embraced). Method is called, after the attribute of the parent has
         * been parsed before and a parent element created, which is given as parameter and to be filled
         * with values by this method.
         * @param parent the parent element, the object list to be parsed belongs to
         * @param input the data string to be parsed
         */
        private void parseObjectsList(ParentElement parent, String input) {
            Deque<String> tokens = tokenizeInput(input);
            if (parent.getAttribute() != null) { // is only null for the rootElement
                // find and assign possible attributes to this parent element
                parseListForAttributes(parent, tokens);
            }
            for (String token : tokens) {

                // recursion base step
                LeafElement parsedLeaf = parseTokenForLeafElement(token);
                if (parsedLeaf != null) {
                    if (!parsedLeaf.getAttribute().isEmpty()) {
                        parent.addValueElement(parsedLeaf);
                    }
                    continue;
                }

                ParentElement parsedObject = parseParentObject(token);
                parent.addValueElement(parsedObject);
                // reduction step of recursion
                parseObjectsList(parsedObject,
                        token.substring(token.indexOf('{') + 1, token.lastIndexOf('}')).trim());
            }
        }

        /**
         * method called after an unsuccessful attempt to parse the object for a leaf element
         * thus, at this point it is clear, that the value is a nested Json-object.
         * the method thus creates a parent element and sets its parsed attribute
         * @param token the string data of this parent object
         * @return the created parent object with attribute set.
         */
        private ParentElement parseParentObject(String token) {
            Matcher matcher = SINGLE_ROOT_PATTERN.matcher(token);
            if (!matcher.matches()) {
                throw new JsonXMLParseException("Json-Parser: Invalid Format");
            }
            ParentElement element = new ParentElement();
            element.setAttribute(matcher.group(1));
            return element;
        }

        /**
         * method gets an arbitrary object and attempts to parse it for a leaf element structure,
         * which may either be a key:value pair with value of data type string, number, boolean or null
         * or a nested object, where all child-elements satisfy an attribute-value pattern, which
         * then represents an XML-element with attributes and (possibly empty) value.
         * @param token the string data of this parent object
         * @return the created leaf object with attribute set - or null, if the objects value is nested
         */
        private LeafElement parseTokenForLeafElement(String token) {

            Matcher matcher = SINGLE_NON_EMPTY_STRING_PATTERN.matcher(token);
            if (matcher.matches()) {
                return new LeafElement(matcher.group(1), matcher.group(2));
            }
            matcher = SINGLE_EMPTY_STRING_PATTERN.matcher(token);
            if (matcher.matches()) {
                return new LeafElement(matcher.group(1), "");
            }
            matcher = SINGLE_NULL_PATTERN.matcher(token);
            if (matcher.matches()) {
                return new LeafElement(matcher.group(1), null);
            }
            matcher = SINGLE_BOOLEAN_PATTERN.matcher(token);
            if (matcher.matches()) {
                return new LeafElement(matcher.group(1), matcher.group(2));
            }
            matcher = SINGLE_NUMBER_PATTERN.matcher(token);
            if (matcher.matches()) {
                return new LeafElement(matcher.group(1), matcher.group(2));
            }

            matcher = SINGLE_ROOT_PATTERN.matcher(token);
            if (!matcher.matches()) {
                throw new JsonXMLParseException("Json-Parser: Invalid format found!");
            }
            LeafElement leafElement = new LeafElement(matcher.group(1), null);
            Deque<String> tokens= tokenizeInput(matcher.group(2));
            if (parseListForAttributes(leafElement, tokens)) {
                leafElement.setValue(parseTokenForLeafElement(tokens.poll()).getValue());
                return leafElement;
            }
            return null;
        }

        /**
         * checks, if the structure has a valid @att1:val1, ..., @att2:val2, #attribute=object_value structure.
         * If this structure is found, all tokens are removed and only the object_value is offered as single
         * new element into the queue.
         * @param element the data structure element, that consists of the content of this tokensQueue
         * @param tokensQueue queue of tokens to be parsed for attribute structure
         * @return true, if the tokens queue matches a valid single (!) XML attributes pattern
         */
        private boolean parseListForAttributes(DataStructureElement element, Deque<String> tokensQueue) {

            String valueKey = String.format("\"#%s\"", element.getAttribute());
            if (isValidAttributesList(tokensQueue, valueKey)) {
                return moveAttributesToElement(element, (LinkedList<String>) tokensQueue);
            } else {
                repairChildList((LinkedList<String>) tokensQueue);
                // empty child elements counts as empty value with key = tag_name
                if (tokensQueue.isEmpty()) {
                    tokensQueue.offer("\"" + element.getAttribute() +"\" :\"\"");
                    return true;
                }
            }
            return false;
        }

        /**
         * this method is called, if the child-list does NOT fully match the attributes-value
         * syntax. It applies some rules given by the specification, that attribute-marked
         * tags are modified to normal child elements, if the whole syntax does not match.
         * also in this case no two child-attributes with same name are allowed.
         * in this case, the one is taken without "@" or "#"...
         * @param tokensList list of tokens after the negative attribute match -> the list is modified !
         */
        private void repairChildList(LinkedList<String> tokensList) {
            Set<String> keySet = new HashSet<>();
            ListIterator<String> iterator = tokensList.listIterator(tokensList.size());
            while (iterator.hasPrevious()) {
                String token = iterator.previous();
                Matcher matcher = JSON_CHILD_TOKEN_PATTERN.matcher(token);
                if (!matcher.matches() || matcher.group(1).isEmpty() || "@".equals(matcher.group(1)) ||
                        ("#".equals(matcher.group(1)))) {
                    iterator.remove();
                    continue;
                }
                if (matcher.group(1).startsWith("@") || matcher.group(1).startsWith("#")) {
                    iterator.set("\"" + token.substring(2));
                    if (keySet.contains(matcher.group(1).substring(1))) {
                        iterator.remove();
                    }
                } else {
                    keySet.add(matcher.group(1));
                }
            }
        }

        /**
         * this method is called, if the child-list does match a valid attributes and
         * value structure of an XML-element. In this case all the attributes are added to the
         * given data structure element's attributesList.
         * @param element a data structure element, where the attributes are added.
         * @param tokensList the tokens list, that matches to attributes key-value pairs and
         *                   the element value itself.
         * @return true, if the value of the element "#tag_name" is a single string and can
         *          thus be processed further into a LeafElement, false if value is nested itself.
         */
        private boolean moveAttributesToElement(DataStructureElement element, LinkedList<String> tokensList) {

            Iterator<String> iterator = tokensList.iterator();
            String valueToken = null;
            while (iterator.hasNext()) {
                String token = iterator.next();
                if (token.startsWith("\"@")) {
                    Matcher matcher = JSON_ATTRIBUTE_PATTERN.matcher(token);
                    matcher.matches(); // clear at this point, that it does
                    String attributeValue = matcher.group(3) != null ? matcher.group(3) : matcher.group(2);
                    if (attributeValue.equals("null")) {
                        attributeValue = "";
                    }
                    element.addAttributeElement(new LeafElement(matcher.group(1), attributeValue));
                    iterator.remove();
                }
                if (token.startsWith("\"#")) {
                    valueToken = token;
                    if (token.contains("{")) {
                        iterator.remove();
                    }
                }
            }
            if (valueToken.contains("{")) {
                tokensList.addAll(tokenizeInput(valueToken
                        .substring(valueToken.indexOf('{')+1, valueToken.lastIndexOf('}')).trim()));
                return false;
            }
            tokensList.set(0, "\"" + valueToken.substring(2));
            return true;
        }

        /**
         * this method applies all specified checks for a child-list, if it matches a valid
         * XML-structure with attributes and value. To be this, all child-elements must either
         * be valid key:string-value pairs for attributes and start with "@" or be the one and
         * only value-attribute, that must have a key "#<tag_name>".
         * @param tokensList the token's collection to be parsed
         * @param valueKey the value-key for this XML-element ("#<tag_name>")
         * @return true, if the child-list matches the attributes structure (with possibly nested value)
         *         false else
         */
        private boolean isValidAttributesList(Deque<String> tokensList, String valueKey) {
            boolean isAttributesList = true;
            boolean valueKeyFound = false;
            for (String token : tokensList) {
                if (token.startsWith(valueKey)) {
                    valueKeyFound = true;
                    continue;
                }
                Matcher matcher = JSON_ATTRIBUTE_PATTERN.matcher(token);
                if (!matcher.matches()) {
                    isAttributesList = false;
                    break;
                }
            }
            return isAttributesList && valueKeyFound;
        }

        /**
         * entry point for a rather complicated parsing of a string, that comprises all data of an
         * arbitrary Json-object (even the root-element in first call) into a list of tokens, that
         * precisely contain the data of one child-element. It has a sub call to a method matching one next token.
         * @param input the input string containing all object's data
         * @return an Array-Deque of the tokens
         */
        private Deque<String> tokenizeInput(String input) {
            Deque<String> tokens = new LinkedList<>();
            int position = 0;
            String token;
            do {
                token = getNextToken(input.substring(position));
                position += token.length() + 1;
                tokens.offer(token.trim());
            } while (position < input.length());
            return tokens;
        }

        /**
         * low level parse-logic, where one token of the input-string is parsed and returned.
         * A token is either a "key":value pair, separated by end of text or ',' - or it is
         * a nested structure, which is identified by counting how many open braces are closed again
         * and delimited again by ',' or text end.
         * @param text the text where the token is taken from the beginning
         * @return the token that exactly matches one Json-element of the list.
         */
        private String getNextToken(String text) {
            int end = text.indexOf('{');
            if (end < 0 || end > text.indexOf(',')) {
                return text.indexOf(',') < 0 ? text : text.substring(0, text.indexOf(','));
            }
            int depth = 1;
            while (++end < text.length() && depth > 0) {
                if (text.charAt(end) == '{') {
                    depth++;
                } else if (text.charAt(end) == '}') {
                    depth--;
                }
            }
            if (text.indexOf(',', end) > 0) {
                return text.substring(0, text.indexOf(',', end));
            }
            if (text.indexOf('{', end) > 0 || text.indexOf(':', end) > 0) {
                throw new JsonXMLParseException("Json-Parser: Invalid format found!");
            }
            return text;
        }
    }
  learner_created: true
- name: src/converter/Converter.java
  visible: true
  learner_created: true
- name: src/converter/Pair.java
  visible: true
  learner_created: true
- name: src/converter/PseudoElement.java
  visible: true
  learner_created: true
- name: src/converter/implementation/json/JSONBuilder.java
  visible: true
  learner_created: true
- name: src/converter/implementation/json/XMLParser.java
  visible: true
  learner_created: true
- name: src/converter/implementation/xml/JSONParser.java
  visible: true
  learner_created: true
- name: src/converter/implementation/xml/XMLBuilder.java
  visible: true
  learner_created: true
- name: src/converter/abstraction/data/JSON.java
  visible: true
  learner_created: true
- name: src/converter/abstraction/data/XML.java
  visible: true
  learner_created: true
- name: src/converter/abstraction/controllers/JSONDirector.java
  visible: true
  learner_created: true
- name: src/converter/abstraction/controllers/XMLDirector.java
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/5476#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">JetBrains
    Academy</a> to continue learning.
  time: Fri, 11 Mar 2022 12:37:46 UTC
record: -1
